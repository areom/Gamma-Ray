#!/bin/bash

# These are things that are just program dependent (Scanner v Parser, etc)
program="$( basename "$0" )"
scriptdir="$( dirname "$0" )"
exe=
old=

# Arguments
save=
verbose=
pattern=*

# Calculated values change in each iteration
current=
results=

# Don't change per iteration
scripts=( $scriptdir/scanner $scriptdir/parser )  ## ADD NEW SCRIPTS HERE
tmpfile="test/check"
tmperr="test/err"
testdir="test/tests"
maxlength=0
oneline=0
files=()

# Formatting values
bold=`tput bold`
normal=`tput sgr0`
uline=`tput smul`
green=`tput setaf 2`
red=`tput setaf 1`


function errWith {
  echo "$1" >&2
  exit 1
}

function execerror {
  echo "${bold}${uline}${red}ERROR${normal} $1"
}

function dots {
  len=`echo "$current" | wc -c`
  for i in `seq $len $maxlength` ; do
    echo -n '.'
  done
  echo -n ' '
}

function dropdirprefix {
  word="$1"
  prefix="$2"
  prefixlen=$(( `echo "$prefix" | wc -c` + 1 ))
  echo "$word" | cut -c $prefixlen-
}

function testit {
  testing="${bold}Testing:${normal} ${uline}${current}${normal}"
  test "$oneline" -eq 0 && echo "$testing"
  test "$oneline" -ne 0 && echo -n "$testing"
  test "$oneline" -ne 0 && dots
  test -n "$verbose" && cat "$1"
  cat "$1" | "$exe" 1> "$tmpfile" 2> "$tmperr"
  if [ $? -ne 0 ] ; then
    execerror "Error testing $program with $current"
    cat "$tmperr"
  elif [ -n "$save" ] ; then
    echo "${bold}Saving${normal} $current"
    mkdir -p $( dirname "$results" )
    mv "$tmpfile" "$results"
  elif [ ! -e "$results" ] ; then
    execerror "Cannot check results -- standard does not exist"
  else
    if [ -n "$verbose" ] ; then
      echo -n "${bold}Output:${normal} "
      cat "$tmpfile"
    fi
    test "$oneline" -eq 0 && echo -n "${bold}Results:${normal} "
    diff -q "$tmpfile" "$results" &> /dev/null
    if [ $? -eq 0 ] ; then
      echo "${bold}${green}PASS${normal}"
    else
      echo "${bold}${red}MISMATCH${normal}"
    fi
  fi

  test -e "$tmpfile" && rm "$tmpfile"  # Sometimes happens
  test -e "$tmperr" && rm "$tmperr"    # Always happens

  test "$oneline" -eq 0 && echo ""
}

function listandexit {
  for afile in $( find "$testdir" -type f -name "$pattern" ) ; do
    current=$( dropdirprefix "$afile" "$testdir" )
    echo "$current"
  done
  exit 0
}

function usage {
cat <<USAGE
$program -[chlpsv]
  -c
     Merely validate that all test scripts are identical and exit

  -h
     Display this help

  -l
     Display the name of all tests; note that pattern can be used

  -p pattern
     Filter tests to be used based on pattern (as in find -name)

  -s
     save results

  -v
     verbose output
USAGE
  exit 0
}

script="${scripts[0]}"
for ascript in "${scripts[@]}" ; do
  scriptfile=$( dropdirprefix "$script" "$scriptdir" )
  ascriptfile=$( dropdirprefix "$ascript" "$scriptdir" )
  diff -q "$script" "$ascript" &> /dev/null || errWith "Test scripts $scriptfile and $ascriptfile differ; they should match."
done

case "$program" in
  scanner)
        exe="./streams"
        old="expect-scanner"
        ;;
  parser)
        exe="./inspect"
        old="expect-parser"
        ;;
  *)
        errWith "Unknown test program $program"
        ;;
esac

while getopts "chlsvp:" OPTION ; do
  case "$OPTION" in
    c) exit 0 ;;
    h) usage ;;
    s) save=1 ;;
    v) verbose=1 ;;
    p) pattern=$OPTARG ;;
    l) list=1;;
    ?) errWith "Unknown option; aborting" ;;
  esac
done
shift $(($OPTIND - 1))

test -n "$list" && listandexit

test -e "$exe" || errWith "Testing $program but $exe unavailable"
test -f "$exe" || errWith "Testing $program but $exe is not a file"
test -x "$exe" || errWith "Testing $program but $exe unexecutable"

test -z "$verbose" && oneline=1

for afile in $( find "$testdir" -type f -name "$pattern" ) ; do
  test "README" = $( basename "$afile" ) || files+=( "$afile" )
done
test "${#files[@]}" -eq 0 && errWith "No files match the given pattern. Good-bye."

for atest in "${files[@]}" ; do
  current=$( dropdirprefix "$afile" "$testdir" )
  len=`echo "$current" | wc -c`
  test $len -gt $maxlength && maxlength="$len"
done
maxlength=$(( maxlength + 5 ))

for atest in "${files[@]}" ; do
  current=$( dropdirprefix "$afile" "$testdir" )
  results="test/$old/$current"

  testit "$atest"
done
