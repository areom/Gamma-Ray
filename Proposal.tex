\documentclass[10pt]{article}
\usepackage{fullpage,listings}
\usepackage{color,xcolor}
\usepackage{caption}

\newcommand{\Lang}{GAMMA}
\newcommand{\ThorsGauntlets}{J\'arngl\'ofar}
\newcommand{\Compiler}{ray}
\newcommand{\OLang}{BETA}

\title{\Lang{}: A \OLang{}++ Programming Language}
\author{
	Ben Caimano - blc2129@columbia.edu \\
	Weiyuan Li - wl2453@columbia.edu \\
	Matthew H Maycock - mhm2159@columbia.edu \\
	Arthy Padma Anandhi Sundaram - as4304@columbia.edu
}
\date{}

\begin{document}

%Title area
\maketitle
\begin{center}
\large
A Project for Programming Languages and Translators,
\\taught by Stephen Edwards
\end{center}


\section*{Why \Lang{} -- or Why Update \OLang{}?}
\OLang{} is a programming language of the ``Scandanvian School'' of Object
orientation. The language provided two primary beneficial features:

\begin{enumerate}
\item The \OLang{} Pattern is used as a unifying concept for every element
of the program -- Classes, Procedures, anonymous Objects, etc.
\item Refinement and specialization is used instead of overriding to
ensure that super-pattern behavior is respected by sub-patterns. A
simple way analogy to understand this is to think how you would program
in Java if all your methods had to be declared \emph{abstract} or
\emph{final}. \OLang{} just provides this structuring and a little help to
make it easier to use.
\end{enumerate}

A consequence of the fact that patterns are refined and everything is a
pattern is that classes can have nested classes and \emph{those} nested
classes can themselves be refined; classes can be \emph{virtual} in the
sense of virtual functions, etc in other languages.

The primary negative about \OLang{} however is that the syntax is horrible
-- absolutely atrocious. While the language provides a nice theoretical
setting for object oriented development given it's pro's, the fact that
the syntax is such a significant con clearly more than negates any of
the benefits. In a world where LISP, the most beautiful language, is
derided for its parentheses, a language like \OLang{} cannot succeed
where Python, Ruby, and other easy to read languages exist.

And so this is the goal of the \Lang{} programing language project; to
make a new language with a feature set similar to what \OLang{} provides
but with a readable syntax that is programmer friendly.

\section*{\OLang{} \& \Lang{} Similarities \& Differences}
If we are making \Lang{} as a replacement for \OLang{} then we need to talk
about the changes this replacement represents. \OLang{} is written without
much syntactic sugar; the Pattern syntax is used pervasively despite the
fact that there are multiple repeated uses of the syntax. This is where a
LISPer would say ``Stop, Macro Time!'' We have repeated syntactic patterns
but a serious line clutter in their use.

This leads us to the goal of \Lang{}: \Lang{} will have syntax for the common
syntactic elements that \OLang{} absorbed into the Pattern mechanism. Since
Patterns in \OLang represented the idea of a computation with a sense of state
-- some sort of mixture between a closure (a behavior with state) and an object
(a piece of state with behavior) -- so will elements of \Lang{}. Just as in
Java there is the "(Almost) Everything Is An Object" mentality, or how in Ruby
"Everything Actually Is An Object," in \Lang{} we will have the mentality that
"Everything Is A Stateful Computation." Thus these various easy to use and
easy to read program elements will behave similarly to Patterns in \OLang{}.

\section*{\Lang{} Feature Set}

\Lang{} will provide the following features:

\begin{itemize}
\item Refinement / Specialization as in \OLang{}
\item Virtual Classes / Members as in \OLang{}
\item Anonymous Instantiation as in \OLang{}
\item Access specifiers respect object boundaries, not class boundaries
\item Everything is a stateful computation (closure / object mixture)
\item References (no Pointers)
\end{itemize}

\section*{\Compiler{}: The \Lang{} Compiler}

\section*{Code Examples}

\begin{lstlisting}[label=The Parent-Child Inheritance,caption=Some Code]
Something!
\end{lstlisting}

\end{document}