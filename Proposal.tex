\documentclass[10pt]{article}
\usepackage{fullpage,listings}
\usepackage{color,xcolor}
\usepackage{caption}

\newcommand{\Lang}{GAMMA}
\newcommand{\ThorsGauntlets}{J\'arngl\'ofar}
\newcommand{\Compiler}{ray}
\newcommand{\OLang}{BETA}

\title{\Lang{}: A \OLang{}++ Programming Language}
\author{
	Ben Caimano - blc2129@columbia.edu \\
	Weiyuan Li - wl2453@columbia.edu \\
	Matthew H Maycock - mhm2159@columbia.edu \\
	Arthy Padma Anandhi Sundaram - as4304@columbia.edu
}
\date{}

\begin{document}

%Title area
\maketitle
\begin{center}
\large
A Project for Programming Languages and Translators,
\\taught by Stephen Edwards
\end{center}


\section*{Why \Lang{} -- or Why Update \OLang{}?}
\OLang{} is a programming language of the ``Scandanvian School'' of Object
orientation. The language provided two primary beneficial features:

\begin{enumerate}
\item The \OLang{} Pattern is used as a unifying concept for every element
of the program -- Classes, Procedures, anonymous Objects, etc.
\item Refinement and specialization is used instead of overriding to
ensure that super-pattern behavior is respected by sub-patterns. A
simple way analogy to understand this is to think how you would program
in Java if all your methods had to be declared \emph{abstract} or
\emph{final}. \OLang{} just provides this structuring and a little help to
make it easier to use.
\end{enumerate}

A consequence of the fact that patterns are refined and everything is a
pattern is that classes can have nested classes and \emph{those} nested
classes can themselves be refined; classes can be \emph{virtual} in the
sense of virtual functions, etc in other languages.

The primary negative about \OLang{} however is that the syntax is horrible
-- absolutely atrocious. While the language provides a nice theoretical
setting for object oriented development given it's pro's, the fact that
the syntax is such a significant con clearly more than negates any of
the benefits. In a world where LISP, the most beautiful language, is
derided for its parentheses, a language like \OLang{} cannot succeed
where Python, Ruby, and other easy to read languages exist.

And so this is the goal of the \Lang{} programing language project; to
make a new language with a feature set similar to what \OLang{} provides
but with a readable syntax that is programmer friendly.

\section*{\OLang{} \& \Lang{} Differences}
If we are making \Lang{} as a replacement for \OLang{} then we need to talk
about the changes this replacement represents. \OLang{} is written without
much syntactic sugar; the Pattern syntax is used pervasively despite the
fact that there are multiple repeated uses of the syntax. This is where a
LISPer would say ``Stop, Macro Time!'' We have repeated syntactic patterns
but a serious line clutter in their use.

This leads us to actually have two goals with respect to updating the syntax
and usability of \OLang{}: first we will create a more readable version of
the \OLang{} Pattern mechanism. As in \OLang, this will be \Lang{}'s primary
way to define program entities, and so will still act as a unifying force
and will be available to the programmer as the ``under the hood'' language
for when it is needed.

The second goal will be to provide syntactic sugar for common Pattern syntax
patterns (please blame \OLang{} developers for choosing Pattern as the name
of their unifying concept, and making these sentences harder to read). We will
provide syntax for classes, methods, and probably several other common patterns
as we develop the language specification.

\section*{\Lang{} Feature Set}

\Lang{} will provide the following features:

\begin{itemize}
\item Unifying Pattern Concept
\item Refinement / Specialization
\item Anonymous Pattern Instantiation
\item Access specifiers respect object boundaries, not class boundaries
\end{itemize}

\section*{\Compiler{}: The \Lang{} Compiler}

The compiler will proceed in two steps. First, the compiler will transform
the source containing the syntactic sugar described above into a file
consisting only of actual patterns. After this the compiler will transform
general patterns into (hopefully portable) C code, and compile this to
machine code with whatever compiler the user specifies.

\section*{Code Examples}

\begin{lstlisting}[label=The Parent-Child Inheritance,caption=Some Code]
Something!
\end{lstlisting}

\end{document}