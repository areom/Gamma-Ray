\section{Syntax}
\subsection{Variable Declaration}
Declaring a variable requires a type and a list of identifiers deliminated by commas:

\begin{lstlisting}
type identifier[, identifier[, identifier[...]]];
\end{lstlisting}

If we wanted to declare variables for the pythagorean theorem, we would do it like so:

\begin{lstlisting}[caption=Variable Initialization for the Pythagorean Theorem]
Float a, b, c;
\end{lstlisting}

\subsection{Variable Declaration with Initialization}

\subsection{Variable Assignment}
Assigning an instance to a variable requires an expression and a variable identifier:

\begin{lstlisting}
identifier := expression;
\end{lstlisting}

If we wanted to assign instances of Integer for our pythagorean theorem, we'd do it like so:

\begin{lstlisting}[caption=Variable Assignment for the Pythagorean Theorem]
a := 3;
b := 4;
\end{lstlisting}

\subsection{Method Invocation}
Invoking a method requires at least an identifier for the method of the current context (i.e. implicit \verb!this! receiver). The instance that the method is invoked upon can be provided as an expression. If it is not provided, the method is invoked upon \verb!this!.

\begin{lstlisting}
[expression.]identifier([expression[, expression[...]]])
\end{lstlisting}

Finishing our pythagorean example, we use method invocations and assignment to calculate the length of our third side, c.

\begin{lstlisting}[label=Method Invocation,caption=Method Invocation for the Pythagorean Theorem Using Methods]
c := ((a.power(2)).plus(b.power(2))).power(0.5);
\end{lstlisting}

\subsection{Method Invocation Using Operators}
Alternatively, certain base methods allow for the use of more familiar binary operators in place of a method invocation.

\begin{lstlisting}
expression operator expression
\end{lstlisting}

Using operators has advantages in clarity and succinctness even if the end result is the same.

\begin{lstlisting}[label=Method Invocation,caption=Method Invocation for the Pythagorean Theorem Using Operators]
c := ( a^2 + b^2 )^0.5;
\end{lstlisting}

\subsection{Operator Precidence}
In the previous examples, parentheses were used heavily in a context not directly related to method invocation. Parentheses have one additional function: they modify precedence among operators. Every operator has a precidence in relation to its fellow operators. Operators of higher precedence are enacted first. Please consider the following table for determining precidence:
\begin{table}[h]
\begin{tabular}{ccccccc}
\verb!:=! & \verb!+=! & \verb!-=! & \verb!*=! & \verb!/=! & \verb!%=! & \verb!^=!\\
or & xor & nor &&&&\\
and & nand &&&&&\\
\verb!=! & \verb!<>! & \verb!=/=! &&&&\\
\verb!>! & \verb!<! & \verb!>=! & \verb!<=! &&&\\
\verb!+! & \verb!-! &&&&&\\
\verb!*! & \verb!/! & \verb!%! &&&&\\
\multicolumn{2}{c}{unary minus}\\
not & \verb!^! &&&&&\\
\multicolumn{3}{c}{array dereferencing}&\verb!(!&\verb!)!&&\\
\multicolumn{3}{c}{method invocation}&&&&\\
\end{tabular}
\caption{Operator Precidence}
\end{table}

\subsection{Method Declaration}
A method definition begins with the return type -- either a type (possibly an n-dimensional array) or void. The identifier for the function is followed by a pair of parentheses that may enclose the argument variable declarations. There is one type and one identifier for each argument; and they are delimited by commas. Following the parentheses are a pair of braces around the body of the method. In the body, there must be at least one statement but there may be many more. There can be zero or more statements in the body.. Additionally, refinements may be placed throughout the statements.
 
\begin{lstlisting}
return_type | void method_identifier ([var_type var_identifier[, var_type var_identifier[, var_type var_identifier[...]]]]){
    [statement*]
    [statement*]
    ...
}
\end{lstlisting}

Finally, we may define a method to do our pythagorean theorem calculation.

\begin{lstlisting}[label=Method Invocation,caption=Method Definition for the Pythagorean Theorem]
Float pythagorean_theorem(Float a, Float b){
    Float c;
    c := ( a^2 + b^2 )^0.5;
    return c;
}
\end{lstlisting}

\subsection{Class Declaration}
A class definition always starts with the keyword \verb!class! followed by a type (i.e. capitalized) identifier. There can be no brackets at the end of the identifier, and so this is a case where the type must be purely alphanumeric mixed with underscores. It optionally has the keyword \verb!extends! followed by the identifier of the superclass. What follows is the class body in brackets: an optional \verb!main! method and the three access-level member sections. There may be \verb!init! methods in any of the three sections, and there must be (semantically enforced, not syntactically) an \verb!init! method either in the protected or public section (for otherwise there would be no way to make methods).

While the grammar allows multiple main methods to be defined in a class, any more than one will result in an error during compilation.

\begin{lstlisting}
class class_identifier [extends superclass_identifier] {
    [main_method]
    [private {
        [private_method_decl | private_var_decl | init_decl]
        [private_method_decl | private_var_decl | init_decl]
        ...
    }]
    [protected {
        [protected_method_decl | protected_var_decl | init_decl]
        [protected_method_decl | protected_var_decl | init_decl]
        ...
    }]
    [public {
        [public_method_decl | public_var_decl | init_decl]
        [public_method_decl | public_var_decl | init_decl]
        ...
    }]
    [refinement {
        [refinement_decl]
        [refinement_decl]
        ...
    }]
}
\end{lstlisting}

Let's make a basic geometric shape class in anticipation of later examples. We have private members, two access-level sections and an init method. No extends is specified, so it is assumed to inherit from Object.


\begin{lstlisting}[label=Method Invocation,caption=Class Declaration for a Geometric Shape class]
class Geometric_Shape {
    private {
        String name;
        Float area;
        Float circumfrence;
    }
    public {
        init (String name) {
            this.name = name;
            if (refinable(improve_name)) {
                this.name += refine improve_name() to String;
            }
            return;
        }
        Float get_area() {
            Float area;
            area := refine custom_area() to Float;
        }
    }
}
\end{lstlisting}

\subsection{Class Instantiation}
Making a new instance of a class is simple.

\begin{lstlisting}
new class_identifier([expr[,expre[,expr[...]]]])
\end{lstlisting}

For instance:

\begin{lstlisting}[label=Method Invocation,caption=Class Instantiation for a Geometric Shape class]
Geometric_Shape = new Geometric_Shape("circle");
\end{lstlisting}

\subsection{Array Declaration}
Declaring an array is almost the same as declaring a normal variable, simply add square brackets after the type.

\begin{lstlisting}
type[] identifier[, identifier[, identifier[...]]];
\end{lstlisting}

\subsection{Array Declaration with Initialization}

have Type[][] var := new Type[][](dim1, dim2) here...

\subsection{Conditional Structures}

\subsection{Refinements}