\section{Syntax}
\subsection{Statement Grouping via Bodies}
A body of statements is a series of statements bounded by curly braces.

\begin{lstlisting}
{
	[stmt1_statement
	[stmt2_statement
	[stmt3_statement
	[...]]]]
}
\end{lstlisting}

\subsection{Variable Assignment}
Assigning an instance to a variable requires an expression and a variable identifier:

\begin{lstlisting}
var_identifier := val_expr;
\end{lstlisting}

If we wanted to assign instances of Integer for our pythagorean theorem, we'd do it like so:

\begin{lstlisting}[caption=Variable Assignment for the Pythagorean Theorem]
a := 3;
b := 4;
\end{lstlisting}

\subsection{Variable Declaration}
Declaring a variable requires a type and a list of identifiers deliminated by commas. Each identifier may be followed by the assignment operator and an expression so as to combine assignment and declaration.

\begin{lstlisting}
var_type var1_identifier [:= val1_expr][, var2_identifier [:= val2_expr][, var3_identifier [:= val3_expr][...]]];
\end{lstlisting}

If we wanted to declare variables for the pythagorean theorem, we would do it like so:

\begin{lstlisting}[caption=Variable Initialization for the Pythagorean Theorem]
Float a, b, c;
\end{lstlisting}

\subsection{Method Invocation}
Invoking a method requires at least an identifier for the method of the current context (i.e. implicit \verb!this! receiver). The instance that the method is invoked upon can be provided as an expression. If it is not provided, the method is invoked upon \verb!this!.

\begin{lstlisting}
[instance_expr.]method_identifier([arg1_expr[, arg2_expr[...]]])
\end{lstlisting}

Finishing our pythagorean example, we use method invocations and assignment to calculate the length of our third side, c.

\begin{lstlisting}[label=Method Invocation,caption=Method Invocation for the Pythagorean Theorem Using Methods]
c := ((a.power(2)).plus(b.power(2))).power(0.5);
\end{lstlisting}

\subsection{Method Invocation Using Operators}
Alternatively, certain base methods allow for the use of more familiar binary operators in place of a method invocation.

\begin{lstlisting}
op1_expr operator op2_expr
\end{lstlisting}

Using operators has advantages in clarity and succinctness even if the end result is the same.

\begin{lstlisting}[label=Method Invocation,caption=Method Invocation for the Pythagorean Theorem Using Operators]
c := ( a^2 + b^2 )^0.5;
\end{lstlisting}

\subsection{Operator Precidence}
In the previous examples, parentheses were used heavily in a context not directly related to method invocation. Parentheses have one additional function: they modify precedence among operators. Every operator has a precidence in relation to its fellow operators. Operators of higher precedence are enacted first. Please consider the following table for determining precidence:
\begin{table}[h]
\begin{tabular}{ccccccc}
\verb!:=! & \verb!+=! & \verb!-=! & \verb!*=! & \verb!/=! & \verb!%=! & \verb!^=!\\
or & xor & nor &&&&\\
and & nand &&&&&\\
\verb!=! & \verb!<>! & \verb!=/=! &&&&\\
\verb!>! & \verb!<! & \verb!>=! & \verb!<=! &&&\\
\verb!+! & \verb!-! &&&&&\\
\verb!*! & \verb!/! & \verb!%! &&&&\\
\multicolumn{2}{c}{unary minus}\\
not & \verb!^! &&&&&\\
\multicolumn{3}{c}{array dereferencing}&\verb!(!&\verb!)!&&\\
\multicolumn{3}{c}{method invocation}&&&&\\
\end{tabular}
\caption{Operator Precidence}
\end{table}

\subsection{Method Declaration \& Definition}
A method definition begins with the return type -- either a type (possibly an n-dimensional array) or void. The identifier for the function is followed by a pair of parentheses that may enclose the argument variable declarations. There is one type and one identifier for each argument; and they are delimited by commas. Following the parentheses are a pair of braces around the body of the method. In the body, there must be at least one statement but there may be many more. There can be zero or more statements in the body.. Additionally, refinements may be placed throughout the statements.
 
\begin{lstlisting}
return_type | void method_identifier ([var_type var_identifier[, var_type var_identifier[, var_type var_identifier[...]]]]) method_body
\end{lstlisting}

Finally, we may define a method to do our pythagorean theorem calculation.

\begin{lstlisting}[label=Method Invocation,caption=Method Definition for the Pythagorean Theorem]
Float pythagorean_theorem(Float a, Float b){
    Float c;
    c := ( a^2 + b^2 )^0.5;
    return c;
}
\end{lstlisting}

\subsection{Class Declaration \& Definition}
A class definition always starts with the keyword \verb!class! followed by a type (i.e. capitalized) identifier. There can be no brackets at the end of the identifier, and so this is a case where the type must be purely alphanumeric mixed with underscores. It optionally has the keyword \verb!extends! followed by the identifier of the superclass. What follows is the class body in brackets: an optional \verb!main! method and the three access-level member sections. There may be \verb!init! methods in any of the three sections, and there must be (semantically enforced, not syntactically) an \verb!init! method either in the protected or public section (for otherwise there would be no way to make methods).

While the grammar allows multiple main methods to be defined in a class, any more than one will result in an error during compilation.

\begin{lstlisting}
class class_identifier [extends superclass_identifier] {
    [main_method]
    [private {
        [private_method_decl | private_var_decl | init_decl]
        [private_method_decl | private_var_decl | init_decl]
        ...
    }]
    [protected {
        [protected_method_decl | protected_var_decl | init_decl]
        [protected_method_decl | protected_var_decl | init_decl]
        ...
    }]
    [public {
        [public_method_decl | public_var_decl | init_decl]
        [public_method_decl | public_var_decl | init_decl]
        ...
    }]
    [refinement {
        [refinement_decl]
        [refinement_decl]
        ...
    }]
}
\end{lstlisting}

Let's make a basic geometric shape class in anticipation of later examples. We have private members, two access-level sections and an init method. No extends is specified, so it is assumed to inherit from Object.


\begin{lstlisting}[label=Method Invocation,caption=Class Declaration for a Geometric Shape class]
class Geometric_Shape {
    private {
        String name;
        Float area;
        Float circumfrence;
    }
    public {
        init (String name) {
            this.name = name;
            if (refinable(improve_name)) {
              this.name += refine improve_name() to String;
            }
            return;
        }
        Float get_area() {
            Float area;
            area := refine custom_area() to Float;
        }
    }
}
\end{lstlisting}

\subsection{Class Instantiation}
Making a new instance of a class is simple.

\begin{lstlisting}
new class_identifier([expr[,expre[,expr[...]]]])
\end{lstlisting}

For instance:

\begin{lstlisting}[label=Method Invocation,caption=Class Instantiation for a Geometric Shape class]
Geometric_Shape = new Geometric_Shape("circle");
\end{lstlisting}

\subsection{Array Declaration}
Declaring an array is almost the same as declaring a normal variable, simply add square brackets after the type. Remember that an array is a type as well, and so the source type can very well be an array of arrays of a certain type before you make declaration. Please note that \{\} are used instead of [] for optional parts in the following for clarity.

\begin{lstlisting}
type[] identifier {:= new type[](dim1_expr)};
\end{lstlisting}

\subsection{Array Dereferencing}
To dereference an instance of an array type down to an instance its element type, place the index of the element instance inside the array instance between [ and ] lexemes after the variable identifier. This syntax can be used to provide a variable for use in assignment or expressions.

\begin{lstlisting}
var_identifier[index_expr]
\end{lstlisting}

\subsection{Conditional Structures}
\subsubsection{If Statements}
The fundamental unit of an if statement is a keyword, followed by a test expression between parentheses, and then a body of statements between curly braces. The first keyword is always \verb!if!, each additional condition to be tested in sequence has the keyword \verb!elsif! and a final body of statements may optionally come after the keyword \verb!else!.

\begin{lstlisting}
if (test1_expr) if1_body
[elsif (test2_expr) if2_body
[elsif(test3_expr) if3_body
[...]]][else if4_body]
\end{lstlisting}

\subsubsection{While Statements}
A while statement consists of only the \verb!while! keyword, a test expression and a body.

\begin{lstlisting}
while(test_expr) while_body
\end{lstlisting}

\subsection{Refinements}
\subsubsection{The Refine Invocation}
A refine invocation will eventually evaluate to an expression as long as the appropriate refinement is implemented. It is formed by using the keyword \verb!refine!, the identifier for the refinement, the keyword \verb!to!, and the type for the desired expression.

\begin{lstlisting}
refine refine_identifier to refine_type
\end{lstlisting}

\subsubsection{The Refinable Test}
The original programmer cannot garuantee that future extenders will implement the refinement. If it is allowable that the refinement does not happen, then the programmer can use the \verb!refinable! keyword as a callable identifier that evaluates to a Boolean instance.

\begin{lstlisting}
refinable(supermethod_identifier.refinement_identifier)
\end{lstlisting}

\subsubsection{The Refinement Declaration}
To declare a refinement, declare a method in your subclass' refinement section with the special identifier \verb!supermethod_identifier.refinement_identifier!.