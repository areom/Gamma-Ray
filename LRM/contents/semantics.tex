\section{Semantics}

\subsection{Types and Variables}
Every \textit{variable} in Gamma is declared with a \textit{type} and an \textit{identifier}. The typing is static and will always be known at compile time for every variable. The variable itself holds a reference to an instance of that type. At compile time, each new instantiation reserves space for one instance of that type. To be an instance of a type, an instance must be an instance of the class of the same name as that type or an instance of one of the set of descendants (i.e. a subclass defined via \verb!extends! or within the transitive closure therein) of that class. While it is possible for any reference to be \verb!null!, the \verb!null! value is not an instance of a class -- it cannot execute methods or access any fields. \verb!null! represents the lack of an instance. For the purposes of method and refinement return types there is a special keyword, \verb!void!, that allows a method or refinement to use the \verb!return! keyword without an expression and thus not produce a value.

\subsubsection{Array Types}
When specifying the type of a variable, the type may have its type identifier followed by one or more \verb![]! lexemes. The lexeme implies that the type is an \textit{array type} of the \textit{element type} that precedes it in the identifier. So if \verb!BankAccount! is the name of a class (which is associated with a type), then \verb!BankAccount! is the type of a zero dimensional array -- i.e. the type of \verb!BankAccount!. However, \verb!BankAccount[]! is the type of an one-dimensional array of element class \verb!BankAccount!. \verb!BankAccount[][][][]! can be considered the type of an array of four dimension and element class \verb!BankAccount!. It is in fact an array of one dimension and the element class \verb!BankAccount[][][]!. Elements of an array are accessed via an expression resulting in an array followed by a left bracket \verb![!, an expression producing an offset index of zero or greater, and a right bracket \verb!]!. Elements are of one dimension less and so are themselves either arrays or are individual instances of the overall class/type involved (i.e. \verb!BankAccount!).

\subsection{Classes, Subclasses, and Their Members}
\Lang{} is a pure object-oriented language, which means every value is an object -- with the exception that \verb!null! represents the lack of an instance / object to refer to and \verb!this! is a special reference for the object of the current context; the use of this is only useful inside the context of a method or constructor and so cannot be used in a main where, technically, it is \verb!null! but its use will be reported with a more descriptive error.

A class always extends another class; a class inherits all of its superclass's methods and may refine the methods of its superclass. A class must contain a constructor routine named \textit{init} and it must invoke its superclass's constructor via the super keyword -- either directly or transitively by referring to other constructors within the class. In the scope of every class, the keyword \verb!this! explicitly refers to the instance itself. Additionally, a class contains three sets of \textit{members} organized in \textit{private}, \textit{protected}, and \textit{public} sections. Members may be either variables or methods. Each class must be derived from another class as a \textit{subclass}. Members in the public section may be accessed (see syntax) by any other object. Members of the protected section may be accessed only by an object of that type or a descendant (i.e. a subtype defined transitively via the \verb!extends! relation). Private members are only accessible by the members defined in that class (and are not accessible to descendants). Note that access is enforced at object boundaries, not class boundaries -- two \verb!BankAccount! objects of the same exact type cannot access each other's balance, which is possible in both Java \& C++, among others.

\subsubsection{The Object Class}
The Object class is the superclass of the entire class hierarchy in \Lang{}. All objects directly or indirectly inherit from it and share its methods. By default, class declarations without extending explicitly are subclasses of Object.

\subsubsection{The Literal Classes}
There are several \textit{literal classes} that contain unique members that hold strictly data. These classes generally have methods developed for most operators. They are also all subclasses of Object.

\subsubsection{Anonymous Classes}
\textit{Anonymous classes} allow for object oriented behavior in circumstances that do not warrent a proper subclass. In one united block of code, anonymous classes instantiate and declare themselves as a subclass of a specific type.

\subsection{Methods}
A method is a reusable subdivision of code that takes multiple (possibly zero) values as arguments and can either return either a value of the type specified for the method, return null, or not return any value in the case that the return type is \verb!void!. Methods of a class can have \textit{refine} statements placed in their bodies. Subclasses must implement \textit{refinements}, special methods that are called in place of their superclass' refine statements, unless the refinements are guarded with a boolean check via the \verb!refinable! operator for their existence -- in which case their implementation is optional.

\subsubsection{Operators}
Since all variables are classes, every operator is in truth a method called from one of its operands with the other operands as arguments -- with the notable exception of the assignment operators which operate at the language level as they deal not with operations but with the maintenance of references. If an operator is not usable with a certain literal class, then it will not have the method implemented as a member. Classes that are not literal classes may implement those methods so as to allow that operation to be performed between two instances of the appropriate type.

\subsection{Expressions and Statements}
The fundamental nature of an expression is that it generates a value. A statement can be a call to an expression, thus a method or a variable. Not every statement is an expression, however.
