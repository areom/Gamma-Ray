\newcommand{\comment}[1]{{\escapegrammar$\bullet$\it\ #1}\\}

\begin{grammar}
      [(colon){$\hskip 0.1cm \Rightarrow$\\$~\hskip 0.75cm$}]
      [(semicolon){\\$~\hskip 0.45cm|\hskip 0.2cm$}]
      [(comma){}]
      [(period){\\}]
      [(quote){\begin{bf}}{\end{bf}}]
      [(nonterminal){$\langle$}{$\rangle$}]

\comment{Classs may extend another class or default to extending Object}
<class>:"class ",<class id>,<extend>," \{ ",<class section>,"{\small *} \}".
<extend>:"$\epsilon$";"extends ",<class id>.

\comment{Sections -- private protected public refinements and main}
<class section>:<refinement>;<access group>;<main>.

\comment{Refinements are named method dot refinement}
<refinement>:"refinement \{ ",<refine>,"{\small *} \}".
<refine>:<return type>,<var id>,".",<var id>,<params>," \{ ",<statement>,"{\small *} \}".

\comment{Access groups contain all the members of a class}
<access group>:<access type>," \{ ",<member>,"{\small *} \}".
<access type>:"private";"protected";"public".
<member>:<var decl>;<method>;<init>.
<method>:<return type>,<var id>,<params>," \{ ",<statement>,"{\small *} \}".
<init>:"init ",<params>," \{ ",<statement>,"{\small *} \}".

\comment{Main is special -- not instance data, starts execution}
<main>:"main ","( ","String[] ",<var id>," )"," \{ ",<statement>,"{\small *} \}".

\comment{Finally, the meat and potatoes}
<statement>:<var decl>," ;";<assignment>," ;";<super>," ;";<return>," ;";<conditional>;<loop>;<expression>," ;".

\comment{Accessing a variable possibly by index}
<lpiece>:<var id>;<lpiece>," [ ",<expression>," ]".

\comment{Accessing a member's member's member etc etc}
<lvalue>:<lpiece>;<lvalue>," . ",<lpiece>.

\comment{Assignment -- lvalues receive the results of expressions}
<assignment>:<lvalue>," := ",<expression>.

\comment{Super invocation is so we can do constructor chaining}
<super>:"super ( ",<args>," )".

\comment{Methods need to be able to return something, too}
<return>:"return ",<expression>.

\comment{Basic control structures}
<conditional>:"if ( ",<expression>," )"," \{ ",<statement>,"{\small *} \} else \{ ",<statement>,"{\small *} \}".
<loop>:"while ( ",<expression>," ) "," \{ ",<statement>,"{\small *} \}".

\comment{Anything that can result in a value}
<expression>:<invocation>;<field>;<variable>;<arithmetic>;<test>;<instantiate>;<refine expr>;<literal>;"( ",<expression>, ")";"null".

\comment{Method invocations always have a receiver}
<invocation>:<expression>," . ",<invoke>.
<invoke>:<var id>," ()";<var id>," ( ",<args>," )".

\comment{Field of some foreign object (or this)}
<field>:<expression>," . ",<variable>.

\comment{Variable values can be indexed or not}
<variable>:<var id>;<variable>," [ ",<expression>," ]".

\comment{Basic arithmetic can and will be done!}
<arithmetic>:<expression>,<bin op>,<expression>;<unary op>,<expression>.
<bin op>:"+";"-";"*";"/";"\%".
<unary op>:"-".

\comment{Common boolean predicates}
<test>:<expression>,<bin pred>,<expression>;<unary pred>,<expression>;"refinable ( ",<var id>," )".
<bin pred>:"and";"or";"xor";"nand";"nor";"$<$";"$<=$";"=";"!=";"$>=$";"$>$".
<unary pred>:"!".

\comment{Making something}
<instantiate>:<object instantiate>;<array instantiate>.
<object instantiate>:"new ",<class id>;"new ",<class id>," ( ",<args>," )".
<array instantiate>:"new ",<type>," [ ",<expression>," ]".

\comment{Refinement takes a specific specialization and notes the required return type}
<refine expr>:"refine ",<specialize>," to ",<type>.
<specialize>:<var id>," ()";<var id>," ( ",<args>," )".

\comment{Literally necessary}
<literal>:<int lit>;<bool lit>;<float lit>;<string lit>.
<float lit>:<digit>,"{\small +} . ",<digit>,"{\small +}".
<int lit>:<digits>,"{\small +}".
<bool lit>:"true";"false".
<string lit>:"``",<string escape seq>,"''".

\comment{Params and args are as expected}
<params>:"( ",<paramlist>," )".
<paramlist>:<var decl>;<paramlist>," , ",<var decl>.
<args>:<expression>;<args>," , ",<expression>.

\comment{All the basic stuff we've been saving up until now}
<var decl>:<type>,<var id>.
<return type>:"unit";<type>.
<type>:<class id>;<type>,"[]".
<class id>:<upper>,<ualphanum>,"{\small *}".
<var id>:<lower>,<ualphanum>,"{\small *}".

\end{grammar}
